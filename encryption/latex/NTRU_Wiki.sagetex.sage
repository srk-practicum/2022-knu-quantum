## -*- encoding: utf-8 -*-
## This file (NTRU_Wiki.sagetex.sage) was *autogenerated* from NTRU_Wiki.tex with sagetex.sty version 2020/08/12 v3.5.
import sagetex
_st_ = sagetex.SageTeXProcessor('NTRU_Wiki', version='2020/08/12 v3.5', version_check=True)
_st_.current_tex_line = 32
_st_.blockbegin()
try:
     N = 11; p = 3; q = 2^5
except:
 _st_.goboom(34)
_st_.blockend()
_st_.current_tex_line = 35
_st_.blockbegin()
try:
 Zx.<x> = ZZ[]
 T = Zx.change_ring(Integers(p)).quotient(x^N-1)
 f = -1 + x + x^2 - x^4 + x^6 + x^9 - x^10
 g = -1 + x^2 + x^3 + x^5 - x^8 - x^10
 m=-1+x^3-x^4-x^8+x^9-x^10
 r=-1+x^2+x^3+x^4-x^5-x^7
except:
 _st_.goboom(42)
_st_.blockend()
try:
 _st_.current_tex_line = 45
 _st_.inline(0, latex(f))
except:
 _st_.goboom(45)
_st_.current_tex_line = 56
_st_.blockbegin()
try:
 def balancedmod(f,q,N):
     g = list(((f[i] + q//2) % q) - q//2 for i in range(N))
     Zx.<x> = ZZ[]
     return Zx(g)
except:
 _st_.goboom(61)
_st_.blockend()
try:
 _st_.current_tex_line = 64
 _st_.inline(1, latex(balancedmod(1+31*x+32*x^2+33*x^3-x^4, 32, 11)))
except:
 _st_.goboom(64)
_st_.current_tex_line = 69
_st_.blockbegin()
try:
 def multiply(f,g,N):
     return (f * g) % (x^N-1)
except:
 _st_.goboom(72)
_st_.blockend()
_st_.current_tex_line = 79
_st_.blockbegin()
try:
 def invertmodprime(f,p,N):
     Zx.<x> = ZZ[]
     # T is a quotient ring constructed from Z[x]
     # after its base being changed to Zp using ideal x^N-1.
     T = Zx.change_ring(Integers(p)).quotient(x^N-1)
     # Lift function converts Zp[x]/x^N-1 back into Zp[x].
     return Zx(lift(1 / T(f)))
except:
 _st_.goboom(87)
_st_.blockend()
try:
 _st_.current_tex_line = 90
 _st_.inline(2, latex(f))
except:
 _st_.goboom(90)
try:
 _st_.current_tex_line = 93
 _st_.inline(3, latex(invertmodprime(f,p,N)))
except:
 _st_.goboom(93)
try:
 _st_.current_tex_line = 95
 _st_.inline(4, latex(f))
except:
 _st_.goboom(95)
_st_.current_tex_line = 102
_st_.blockbegin()
try:
 def invertmodpowerof2(f,q,N):
     a=2
     b=invertmodprime(f, 2, N)
     while a<q:
         a=a^2
         b=multiply(b, (2-multiply(f,b,N)),N)
         Za.<z>=PolynomialRing(Integers(a))
         f1=Zx(Za(b))
     Zq.<x>=PolynomialRing(Integers(q))
     return Zx(Zq(b))
except:
 _st_.goboom(113)
_st_.blockend()
try:
 _st_.current_tex_line = 116
 _st_.inline(5, latex(f))
except:
 _st_.goboom(116)
try:
 _st_.current_tex_line = 119
 _st_.inline(6, latex(invertmodpowerof2(f,q,N)))
except:
 _st_.goboom(119)
_st_.current_tex_line = 124
_st_.blockbegin()
try:
 def validateparams():
     if q > p and gcd(p,q) == 1:
         return True
     return False
except:
 _st_.goboom(129)
_st_.blockend()
_st_.current_tex_line = 133
_st_.blockbegin()
try:
 def generatepolynomial(d,N):
     assert d <= N
     result = N*[0]
     for j in range(d):
         while True:
             r = randrange(N)
             if not result[r]: break
         result[r] = 1-2*randrange(2)
     return Zx(result)
except:
 _st_.goboom(143)
_st_.blockend()
_st_.current_tex_line = 147
_st_.blockbegin()
try:
 def generatekeys(N):
     if validateparams():
         while True:
             try:
                 f = generatepolynomial(d,N)
                 g = generatepolynomial(d,N)
                 f_q = invertmodpowerof2(f,q)
                 f_p = invertmodprime(f,p,N)
                 break
             except:
                 pass
         public_key = balancedmod(p * multiply(f_q,g,N),q)
         secret_key = f,f_p
         return public_key,secret_key
     else:
         print("Provided params are not correct. q and p should be co-prime, q should be a power of 2 considerably larger than p and p should be prime.")
 
except:
 _st_.goboom(165)
_st_.blockend()
_st_.current_tex_line = 169
_st_.blockbegin()
try:
 def generatemessage():
     result = list(randrange(3) - 1 for j in range(N))
     return Zx(result)
except:
 _st_.goboom(173)
_st_.blockend()
_st_.current_tex_line = 179
_st_.blockbegin()
try:
 def encrypt(message, publickey,r,N):
       Zq.<x>=PolynomialRing(Integers(q))
       return Zx(Zq(balancedmod(multiply(publickey,r,N) + message,q,N)))
       #return balancedmod(multiply(publickey,r,N) + message,q,N)
except:
 _st_.goboom(184)
_st_.blockend()
try:
 _st_.current_tex_line = 187
 _st_.inline(7, latex(m))
except:
 _st_.goboom(187)
try:
 _st_.current_tex_line = 190
 _st_.inline(8, latex(-1+x^2+x^3+x^4-x^5-x^7))
except:
 _st_.goboom(190)
try:
 _st_.current_tex_line = 193
 _st_.inline(9, latex(balancedmod(multiply(g,p*invertmodpowerof2(f,q,N),N),q,N)))
except:
 _st_.goboom(193)
try:
 _st_.current_tex_line = 196
 _st_.inline(10, latex(encrypt(m,balancedmod(multiply(g,p*invertmodpowerof2(f,q,N),N),q,N),r,N)))
except:
 _st_.goboom(196)
_st_.endofdoc()
