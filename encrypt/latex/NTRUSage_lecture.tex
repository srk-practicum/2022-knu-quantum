\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb} 

% set font encoding for PDFLaTeX, XeLaTeX, or LuaTeX
\usepackage{ifxetex,ifluatex}
\if\ifxetex T\else\ifluatex T\else F\fi\fi T%
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{lmodern}
\fi

\usepackage{hyperref}

\title{NTRU Post-Quantum Encryption demo}
\author{Dmytro Husan}

% Enable SageTeX to run SageMath code right inside this LaTeX file.
% http://doc.sagemath.org/html/en/tutorial/sagetex.html
\usepackage{sagetex}

% Enable PythonTeX to run Python â€“ https://ctan.org/pkg/pythontex
% \usepackage{pythontex}

\begin{document}
\maketitle
\section{Example from lecture}
\noindent Let us try to re-create example from lecture
\noindent We use the following common parameters:
\begin{sageblock}
    N = 7; p = 3; q = 41
\end{sageblock}
\begin{sagesilent}
Zx.<x> = ZZ[]
T = Zx.change_ring(Integers(p)).quotient(x^N-1)
f = x^6 - x^4 + x^3 + x^2 - 1
def find_degree(coefs_list):
    """ 
    returns the degree of polynomial 
    """
    for i in range(len(coefs_list)-1, -1, -1):
        if coefs_list[i] != 0:
            return i
\end{sagesilent}
Select random polynomial: 
\[
f=\sage{f}
\]
Check that polynomials $f_p$ and $f_q$ with the property $f\cdot f_p=1 (\mathrm{mod} p)$ 
and $f\cdot f_q =1 (\mathrm{mod} q)$ exist.
\subsection{balancedmod(f(x),q,N)}
This is auxiliary helper function. It reduces every coefficient of a polynomial $f\in\mathbb{Z}[x]$ modulo $q$ with additional balancing, so the result coefficients are integers in interval $[-q/2, +q/2].$ More specifically:
\begin{itemize}
\item for an odd $q$ coefficients belong to $[-\frac{q-1}{2}, + \frac{q-1}{2} ]$ 
\item for an even $q$ coefficients belong to $[-\frac{q}{2}, +\frac{q}{2}-1]$
\end{itemize}
Finally the resulting polynomial is fit into $\mathbb{Z}[x]$ and returned.
\begin{sageblock}
def balancedmod(f,q):
    g = list(((f[i] + q//2) % q) - q//2 for i in range(N))
    Zx.<x> = ZZ[]
    return Zx(g)
\end{sageblock}
Example:
\[
\mathrm{\mathrm{balancedmod}}(1+31x+32x^2+33x^3-x^4, 32) = \sage{balancedmod(1+31*x+32*x^2+33*x^3-x^4, 32)}
\]

\subsection{multiply(f(x), g(x))}
The following function performs multiplication operation specific for NTRU, which works like a traditional polynomial multiplication with additional reduction of the result by $x^N-1$
\begin{sageblock}
def convolution(f,g):
    return (f * g) % (x^N-1)
\end{sageblock}

\subsection{invertmodprime(f(x),p)}
This routine calculates an inversion of a polynomial modulo $x^N-1$ 
and then modulo $p$ with assumption that $p$ is prime number.
Returns a polynomial $f_p\in\mathbb{Z}[x]$ such as $f\cdot f_p = 1(\mathrm{mod} p.$ 
An exception is thrown if such polynomial $f_p\in\mathbb{Z}[x]$ does not exist.
\begin{sageblock}
def invertmodprime(f,p):
    Zx.<x> = ZZ[]
    Zq.<z> = PolynomialRing(Integers(p))
    ZQphi.<Z> = Zq.quotient(z^N-1)
    a = f % p
    a = a.subs(x=z)
    k = 0
    b = 1*z^0
    c = 0*z^0
    f = a 
    g = z^N-1
    
    if a.gcd(g) != 1:
        raise Exception("inversion dosen't exist!")      
    while True:
        while list(f)[0] == 0:
            f /= Z
            c *= Z
            k += 1        
        if find_degree(list(f)) == 0:
            b = 1/list(f)[0] * b
            res = Z^(N-k) * b
            return Zx(res.lift())       
        if find_degree(list(f)) < find_degree(list(g)):
            f, g = g, f
            b, c = c, b       
        u = list(f)[0] * (1/list(g)[0])
        f -= u*g
        b -= u*c

\end{sageblock}
Example:
\[
f=\sage{f}, p=3, N=7
\]
\[
f_p=\mathrm{invertmodprime(f,p)}=\sage{invertmodprime(f,p)}
\]
Note that this is exactly the inverse mentioned in lecture
\subsection{invertmodprime(f(x), q, N)}
This routine calculates an inversion of a polynomial modulo $x^N-1$ 
and then modulo $q$.
Returns a polynomial $f_q\in\mathbb{Z}[x]$ such as $f\cdot f_q = 1(\mathrm{mod} q.$ 
An exception is thrown if such polynomial $f_q\in\mathbb{Z}[x]$ does not exist.
Example:
\[
f=\sage{f}, p=3, N=7, q = 41
\]
\[
f_q=\mathrm{invertmodprime(f,q)}=\sage{invertmodprime(f,q)}
\]
Note that this is exactly the inverse mentioned in lecture.
\subsection{generate\_keys(f, g)}
In this section we will generate public and secret key. To generate the key pair two polynomials $f$ and $g$, with degree at most ${\displaystyle \ N-1} $  and with coefficients in $\{-1,0,1\}$ are required. They can be considered as representations of the residue classes of polynomials modulo ${\displaystyle \ X^{N}-1} $  in $R$.
The polynomial ${\displaystyle {\textbf {f}}\in L_{f}}  $  must satisfy the additional requirement that the inverses modulo $q$ and modulo $p$ (computed using the Euclidean algorithm) exist, which means that ${\displaystyle \ {\textbf {f}}\cdot {\textbf {f}}_{p}=1{\pmod {p}}} $ and $ {\displaystyle \ {\textbf {f}}\cdot {\textbf {f}}_{q}=1{\pmod {q}}}  $ must hold.  The public key $\textbf {h}$ is generated computing the quantity. 
${\displaystyle {\textbf {h}}=p{\textbf {f}}_{q}\cdot {\textbf {g}}{\pmod {q}}.}  $
The secret key is a pair of randomly generated polynomials $(f(x), g(x))$
\begin{sagesilent}
def validate_params():
    ''' checks params meet certain conditions: if q is considerably larger than p
        and if greatest common divider of p and q is 1 
        
        returns N, p, q '''
  
    if q > p and gcd(p,q) == 1:
        return True
    return False

def generate_polynomial(d1, d2):
    ''' generates a random polynomial with d nonzero coefficients
        returns Zx polynomial '''
    assert (d1 + d2) <= N       
    
    result = [1]*d1 + [-1]*d2 + [0]*(N-d1-d2)  
    shuffle(result)
    
    return Zx(result)
\end{sagesilent}
\begin{sageblock}
def generate_keys(polynomial_1 = None, polynomial_2= None):
    # validate params
    if validate_params():
        while True:
            try:
                if polynomial_1 is None or polynomial_2 is None:   

                    f = generate_polynomial(d+1, d)
                    g = generate_polynomial(d, d)
                else:
                    # it use your polynomials
                    f = polynomial_1
                    g = polynomial_2
                

                # formula: find f_q, where: f_q (*) f = 1 (mod q)
                # assuming q is a power of 2                 
                f_q = invertmodprime(f,q)

                # formula: find f_p, where: f_p (*) f = 1 (mod p) 
                # assuming p is a prime number 
                f_p = invertmodprime(f,p)  
                break
        
            except:
                pass 
    
        #formula: public key = F_q ~ g (mod q)
        public_key = balancedmod(p * convolution(f_q,g),q)

   
        secret_key = f,f_p
        return public_key,secret_key

    else:
        print("")

\end{sageblock}
Example: In this example the parameters (N, p, q) will have the values N = 7, p = 3 and q = 41 and therefore the polynomials f and g are of degree at most 6. The system parameters (N, p, q) are known to everybody. The polynomials are randomly chosen, so suppose they are represented by \\ $f(x) = x^6 - x^4 + x^3 + x^2 - 1$, $g(x)=x^6 + x^4 -x^2 - x$
\begin{sagesilent}
public_key, secret_key = generate_keys(x^6 - x^4 + x^3 + x^2 - 1, x^6 + x^4 -x^2 - x)
j = convolution(invertmodprime(f,q),x^6 + x^4 -x^2 - x) 

\end{sagesilent}
\[
public\_key=\mathrm{get\_keys(f, g)}=\sage{j.change_ring(Integers(q))}
\]
\subsection{encrypt(message, public\_key)}
The ciphertext $\textbf {e}$ is generated computing the quantity. 
${\displaystyle {\textbf {e}}={\textbf {r}}\cdot {\textbf {h}+\textbf{m}}{\pmod {q}}.}  $
\begin{sageblock}
def encrypt(message, public_key, r):
    return balancedmod(convolution(public_key,r) + message,q)
\end{sageblock}
Example. Let's choose message $\textbf{m}=-x^5 + x^3+x^2-x+1$ and random polynomial $\textbf{r}=x^6 - x^5 +x - 1$
\[
\textbf{e}=\mathrm{encrypt(message, public\_key)}=\sage{encrypt(-x^5 + x^3+x^2-x+1, public_key, x^6 - x^5 +x - 1).change_ring(Integers(q))}
\]
\subsection{decrypt(encrypted\_message, secret\_key)}
Let's decrypt the message. $\textbf{a}=\textbf{f}\cdot \textbf{e} = p\textbf{r}\cdot \textbf{g} + \textbf{f} \cdot \textbf{m}$ (mod q). The next step will be to calculate \textbf{a} modulo p: $\textbf{b} = \textbf{a} = \textbf{f}\cdot \textbf{m} $ modulo p. $\textbf{c} = \textbf{f}_p \cdot \textbf{b} = \textbf{f}_p \cdot \textbf{f} \cdot \textbf{m}=\textbf{m} $ (mod p).
\begin{sageblock}
def decrypt(encrypted_message, secret_key):    
    # private key - f; additional variable stored for decryption - f_p     
    f,f_p = secret_key
    
    # formula: a = f ~ encrypted_message (mod q)
    # balance coefficients of a for the integers in interval [-q/2, +q/2]
    a = balancedmod(convolution(encrypted_message,f),q)
     
    # formula: F_p ~ a (mod p) with additional balancing as above
    return balancedmod(convolution(a,f_p),p)
\end{sageblock}
Example.
\begin{sagesilent}

encrypted_message=encrypt(-x^5 + x^3+x^2-x+1, public_key, x^6 - x^5 +x - 1)
a = convolution(encrypted_message,f) % 41
\end{sagesilent}
\[
\textbf{a}=\mathrm{\textbf{f} \cdot \textbf{e}}=\sage{a.change_ring(Integers(q))}
\]
after central lift
\[
\textbf{b}=\mathrm{\textbf{a}}=\sage{balancedmod(a, p)}
\]
\[
\textbf{c}=\sage{decrypt(encrypted_message, secret_key)}
\]
We got the original message.


\end{document}
