## -*- encoding: utf-8 -*-
## This file (2022-01-03-181142-truncated.sagetex.sage) was *autogenerated* from 2022-01-03-181142-truncated.tex with sagetex.sty version 2020/08/12 v3.5.
import sagetex
_st_ = sagetex.SageTeXProcessor('2022-01-03-181142-truncated', version='2020/08/12 v3.5', version_check=True)
_st_.current_tex_line = 32
_st_.blockbegin()
try:
     N = 11; p = 3; q = 2^5
except:
 _st_.goboom(34)
_st_.blockend()
_st_.current_tex_line = 35
_st_.blockbegin()
try:
 Zx.<x> = ZZ[]
 T = Zx.change_ring(Integers(p)).quotient(x^N-1)
 f = -1 + x + x^2 - x^4 + x^6 + x^9 - x^10
 def find_degree(coefs_list):
     """
     returns the degree of polynomial
     """
     for i in range(len(coefs_list)-1, -1, -1):
         if coefs_list[i] != 0:
             return i
except:
 _st_.goboom(46)
_st_.blockend()
try:
 _st_.current_tex_line = 49
 _st_.inline(0, latex(f))
except:
 _st_.goboom(49)
_st_.current_tex_line = 60
_st_.blockbegin()
try:
 def balancedmod(f,q):
     g = list(((f[i] + q//2) % q) - q//2 for i in range(N))
     Zx.<x> = ZZ[]
     return Zx(g)
except:
 _st_.goboom(65)
_st_.blockend()
try:
 _st_.current_tex_line = 68
 _st_.inline(1, latex(balancedmod(1+31*x+32*x^2+33*x^3-x^4, 32)))
except:
 _st_.goboom(68)
_st_.current_tex_line = 73
_st_.blockbegin()
try:
 def convolution(f,g):
     return (f * g) % (x^N-1)
except:
 _st_.goboom(76)
_st_.blockend()
_st_.current_tex_line = 83
_st_.blockbegin()
try:
 def invertmodprime(f,p):
     Zx.<x> = ZZ[]
     Zq.<z> = PolynomialRing(Integers(p))
     ZQphi.<Z> = Zq.quotient(z^N-1)
     a = f % p
     a = a.subs(x=z)
     k = 0
     b = 1*z^0
     c = 0*z^0
     f = a
     g = z^N-1
 
     if a.gcd(g) != 1:
         raise Exception("inversion dosen't exist!")
     while True:
         while list(f)[0] == 0:
             f /= Z
             c *= Z
             k += 1
         if find_degree(list(f)) == 0:
             b = 1/list(f)[0] * b
             res = Z^(N-k) * b
             return Zx(res.lift())
         if find_degree(list(f)) < find_degree(list(g)):
             f, g = g, f
             b, c = c, b
         u = list(f)[0] * (1/list(g)[0])
         f -= u*g
         b -= u*c
 
except:
 _st_.goboom(114)
_st_.blockend()
try:
 _st_.current_tex_line = 117
 _st_.inline(2, latex(f))
except:
 _st_.goboom(117)
try:
 _st_.current_tex_line = 120
 _st_.inline(3, latex(invertmodprime(f,p)))
except:
 _st_.goboom(120)
try:
 _st_.current_tex_line = 122
 _st_.inline(4, latex(f))
except:
 _st_.goboom(122)
_st_.current_tex_line = 128
_st_.blockbegin()
try:
 def invertmodpowerof2(f, p):
     r = int(math.log(p, 2))
     p = 2
     q = p
     b = invertmodprime(f, p)
     while q < p^r:
         q = q^2
         b = b * (2 - f*b) % q % (x^N-1)
     b = b % p^r % (x^N - 1)
     return b
except:
 _st_.goboom(139)
_st_.blockend()
try:
 _st_.current_tex_line = 142
 _st_.inline(5, latex(f))
except:
 _st_.goboom(142)
try:
 _st_.current_tex_line = 145
 _st_.inline(6, latex(invertmodpowerof2(f,q)))
except:
 _st_.goboom(145)
try:
 _st_.current_tex_line = 147
 _st_.inline(7, latex(f))
except:
 _st_.goboom(147)
_st_.current_tex_line = 153
_st_.blockbegin()
try:
 def validate_params():
     ''' checks params meet certain conditions: if q is considerably larger than p
         and if greatest common divider of p and q is 1
 
         returns N, p, q '''
 
     if q > p and gcd(p,q) == 1:
         return True
     return False
 
 def generate_polynomial(d1, d2):
     ''' generates a random polynomial with d nonzero coefficients
         returns Zx polynomial '''
     assert (d1 + d2) <= N
 
     result = [1]*d1 + [-1]*d2 + [0]*(N-d1-d2)
     shuffle(result)
 
     return Zx(result)
except:
 _st_.goboom(173)
_st_.blockend()
_st_.current_tex_line = 174
_st_.blockbegin()
try:
 def generate_keys(polynomial_1 = None, polynomial_2= None):
     # validate params
     if validate_params():
         while True:
             try:
                 if polynomial_1 is None or polynomial_2 is None:
 
                     f = generate_polynomial(d+1, d)
                     g = generate_polynomial(d, d)
                 else:
                     # it use your polynomials
                     f = polynomial_1
                     g = polynomial_2
 
 
                 # formula: find f_q, where: f_q (*) f = 1 (mod q)
                 # assuming q is a power of 2
                 f_q = invertmodpowerof2(f,q)
 
                 # formula: find f_p, where: f_p (*) f = 1 (mod p)
                 # assuming p is a prime number
                 f_p = invertmodprime(f,p)
                 break
 
             except:
                 pass
 
         #formula: public key = F_q ~ g (mod q)
         public_key = balancedmod(p * convolution(f_q,g),q)
 
 
         secret_key = f,f_p
         return public_key,secret_key
 
     else:
         print("")
 
except:
 _st_.goboom(212)
_st_.blockend()
_st_.current_tex_line = 214
_st_.blockbegin()
try:
 public_key, secret_key = generate_keys(-1+x+x^2-x^4+x^6+x^9-x^10, -1+x^2+x^3+x^5-x^8-x^10)
 
 
except:
 _st_.goboom(218)
_st_.blockend()
try:
 _st_.current_tex_line = 220
 _st_.inline(8, latex(public_key))
except:
 _st_.goboom(220)
_st_.current_tex_line = 225
_st_.blockbegin()
try:
 def encrypt(message, public_key, r):
     return balancedmod(convolution(public_key,r) + message,q)
except:
 _st_.goboom(228)
_st_.blockend()
try:
 _st_.current_tex_line = 231
 _st_.inline(9, latex(encrypt(-1+x^3-x^4-x^8+x^9+x^10, public_key, -1+x^2+x^3+x^4-x^5-x^7).change_ring(Integers(q))))
except:
 _st_.goboom(231)
_st_.current_tex_line = 235
_st_.blockbegin()
try:
 def decrypt(encrypted_message, secret_key):
     # private key - f; additional variable stored for decryption - f_p
     f,f_p = secret_key
 
     # formula: a = f ~ encrypted_message (mod q)
     # balance coefficients of a for the integers in interval [-q/2, +q/2]
     a = balancedmod(convolution(encrypted_message,f),q)
 
     # formula: F_p ~ a (mod p) with additional balancing as above
     return balancedmod(convolution(a,f_p),p)
except:
 _st_.goboom(246)
_st_.blockend()
_st_.current_tex_line = 248
_st_.blockbegin()
try:
 
 encrypted_message=encrypt(-1+x^3-x^4-x^8+x^9+x^10, public_key, -1+x^2+x^3+x^4-x^5-x^7)
 a = convolution(encrypted_message,f) % 32
except:
 _st_.goboom(252)
_st_.blockend()
try:
 _st_.current_tex_line = 254
 _st_.inline(10, latex(a))
except:
 _st_.goboom(254)
try:
 _st_.current_tex_line = 258
 _st_.inline(11, latex(balancedmod(a, p)))
except:
 _st_.goboom(258)
try:
 _st_.current_tex_line = 261
 _st_.inline(12, latex(decrypt(encrypted_message, secret_key)))
except:
 _st_.goboom(261)
_st_.endofdoc()
